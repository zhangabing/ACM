#RSA算法实现

##1. 实验目的 
通过本课程的实验教学，使学生较全面的了解相关密码算法的基本概念和应用，增强学生对密码算法的认识和理解，为更深入地学习和今后从事与安全 相关工作打下良好的基础。

了解公钥算法基本原理和RSA算法的原理。了解RSA算法在数据加密和数字签名中的应用。了解RSA算法中大和数分解的困难性，从而理解单向函数的 内涵

##2. 实验题目 
1. 编程实现素数的选择判断 
2. 编程实现模逆算法。 
3. 编程实现快速模指运算。 
4. 编程实现RSA算法。 
5. 编程实现利用RSA进行数据加解密。 
6. 实现利用RSA对较大数据进行加解密（选作） 
7. 实现简单的GUI界面

##3. 实验原理与理论基础 

###（一）、整体过程
####1、公钥和私钥的产生

 假设Alice想要通过一个不可靠的媒体接收Bob的一条私人信息。她可以用以下的方式来产生一个公钥和一个私钥：

 RSA体制生成密钥的过程可以简单描述如下：

（1）生成两个大素数p和q。

（2）计算这两个素数的乘积n=p×q。

（3）计算欧拉函数φ(n)=(p-1)(q-1)。

（4）选择一个随机数e满足1<e<φ(n)，并且e和φ(n)互质，即gcd(e,φ(n))=1。

（5）计算ed=1 mod φ(n)。同余：ed-1能被φ(n)整除

（6）保密d，p和q，公开n和e

这里的（n, e）就是公开的加密密钥。（n，d）就是私钥。Alice將她的公钥(N,e)传給Bob，而將她的私钥(N,d)藏起來。

####2、加密消息

 假设Bob想给Alice送一个消息m，他知道Alice产生的N和e。他使用起先与Alice约好的格式将m转换为一个小于N的整数n，比如他可以将每一个字转换为这个字的Unicode码，然后将这些数字连在一起组成一个数字。假如他的信息非常长的话，他可以将这个信息分为几段，然后将每一段转换为n。用下面这个公式他可以将n加密为c： 

![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129221225069-1361510797.png)

计算c并不复杂。Bob算出c后就可以将它传递给Alice。
 
####3、解密消息
 Alice得到Bob的消息c后就可以利用她的密钥d来解码。她可以用以下这个公式来将c转换为n：

![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129221248856-1659102946.png)

得到n后，她可以将原来的信息m重新复原。解码的原理是 ：  

![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129221320539-2125625365.png)

以及ed ≡ 1 (mod p-1)和ed ≡ 1 (mod q-1)。由费马小定理可证明（因为p和q是质数）

![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129221336732-583454584.png)

![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129221345737-655696012.png)

这说明（因为p和q是不同的质数，所以p和q互质）

![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129221403408-1759836363.png)


###（二）、安全性分析
 RSA的安全性依赖于大整数分解，但是否等同于大数分解一直未能得到理论上的证明，因为没有证明破解 RSA就一定需要作大数分解。假设存在一种无须分解大数的算法，那它肯定可以修改成为大数分解算法。
 
目前， RSA 的一些变种算法已被证明等价于大数分解。不管怎样，分解n是最显然的攻击方法。现在，人们已能分解多个十进制位的大素数。因此，模数n必须选大一些，因具体适用情况而定。

##4. 实验内容 

实验内容主要包括实验的实施方案、步骤、实验数据准备、以及可能用到的仪器设备。

###**实验环境**：
本实验是使用C++语言，在codeblocks上面完成本实验
###**实验过程**
1. 本来是了解RSA的原理的，但是因为已经对RSA有所了解，因此只是大致的复习了一下RSA的知识
1. 因为以前就已经了解过模逆运算，模指运算，所以一开始直接书写这两个算法的代码
2. 由于我对本实验的n的定值范围是long long， 因此会涉及到两个long long型的变量的乘积，而导致溢出，因此根据模指运算的原理，写了mul_mod方法，用于实现可能溢出模乘，大致原理就是利用二进制的思维，把乘法转化为加法，而且复杂度是log级别
3. 基于long long的素数判定的话，其实是可以直接在 **√** 的时间内算出来的，并且可以保证素数的准确性。但还是使用了Miller-Rabin素数判定法，出于对这个算法的加深理解的初衷，结合书本和网上的知识，将其实现
4. 然后是利用Miller-Rabin素数判定，生成素数pq，一开始的时候是不停rand（），但是写完发现很难出现素数，联想到素数的密度大概是1/ln，就换了一个方法，从rand（）开始自增查找素数，就可以在短时间内找到一个随机素数
5. 根据素数pq，计算出n的值，还有phi（n）的值，同时进行公钥和密钥的生成
6. 加解密的部分，一开始是考虑是明文，密文的类型，后来还是敲定明文为字符串，密文为一long long类型的整数序列，加密就是对于每一个字符转化为一个long long 的整数，解密就是将一个整数转化为一个字符
7. 完成以上核心部分之后，就是决定完成程序的运行了，由于能力和时间问题，依旧选择的是控制台界面，实现功能有
	1. 生成公钥私钥
	2. 输入明文和公钥进行加密获取密文
	3. 输入密文和密钥进行解密获取明文
###**数据准备**

#####公钥
>n = 2142595640794675597	

>publicKey = 667191463

#####私钥
>n = 2142595640794675597	

>privateKey = 408303107830327927

#####明文

>zhangab

#####密文

>990005600747334113
>
>673618853601587198
>
566245734301499889
>
212546879389580427

>1644656237834577817

>566245734301499889

>649990199774488382

##5. 实验结果 

###程序开始
![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129225217615-804300349.png)
###功能选择
![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129225405947-2081464641.png)
###生成公钥私钥
![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129225511847-559746831.png)
![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129225521038-1022934623.png)
###加密明文
![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129225604373-2107273804.png)
![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129225644115-1314717381.png)
###正确密钥前提下解密密文
![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129225942342-492038029.png)
![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129230258174-502689653.png)
###错误密钥前提下解密密文
![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129225942342-492038029.png)
![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129230824809-287858284.png)
###操作错误
![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129230343364-341537656.png)
###程序结束
![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129230441484-2033938953.png)
![](https://img2018.cnblogs.com/blog/1482155/201811/1482155-20181129230501650-167691971.png)


##6. 实验结果分析 
###分析：

加密密钥（即公开密钥）e是公开信息，而解密密钥（即秘密密钥）d是需要保密的。加密算法和解密算法也都是公开的。虽然解密密钥d是由公开密钥e决定的，由于无法计算出大数n的欧拉函数phi(N)，所以对应的密钥d就无法在有效时间内计算得到。当不知道密钥而使用错误密钥，强行对密文进行解密也只能得到一串乱码。

###结论：

只要保证私钥不被泄漏，就可以保证RSA加密的安全性
